[
  adminroutes: [
// src/routes/adminRoutes.ts
import { Router, Request, Response, NextFunction } from "express";
import {
  createAdmin,
  getAllAdmins,
  getAdminById,
  updateAdmin,
  deleteAdmin,
} from "../controllers/adminController";
import { validateUUID } from "../middleware/validateUUID";

const router = Router();

router.post("/", createAdmin);
router.get("/", getAllAdmins);
router.get("/:id", validateUUID, getAdminById);
router.put("/:id", validateUUID, updateAdmin);
router.delete("/:id", validateUUID, deleteAdmin);

export default router;

  ]
adminmodel: [
  // src/models/adminModel.ts

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
  Length,
  Matches,
} from "class-validator";

@Entity()
export class Admin {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ nullable: true })
  @IsString()
  @IsOptional()
  @Length(2, 100)
  name?: string;

  @Column({ unique: true })
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @Column({ nullable: true })
  @IsOptional()
  @IsString()
  @Length(6, 100)
  password?: string;

  @Column({ unique: true, nullable: true })
  @IsOptional()
  @IsString()
  @Matches(/^\d{7,15}$/, {
    message: "Phone must be digits only and 7 to 15 characters long",
  })
  phone?: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

]
]
[
  examroutes: [
import { Router } from "express";
import {
  createExam,
  getAllExams,
  getExamById,
  updateExam,
  deleteExam,
  assignClassesToExam,
  unassignClassesFromExam,
  getStudentsForExam,
} from "../controllers/examController";
import { protect, restrictTo } from "../middleware/authMiddleware";

const router = Router();

// CRUD routes
router.post("/", protect, restrictTo("admin"), createExam);
router.get("/", getAllExams);
router.get("/:id", getExamById);
router.put("/:id", protect, restrictTo("admin"), updateExam);
router.delete("/:id", protect, restrictTo("admin"), deleteExam);

// Assignment routes
router.post(
  "/:id/classes/assign",
  protect,
  restrictTo("admin", "teacher"),
  assignClassesToExam
);
router.post(
  "/:id/classes/unassign",
  protect,
  restrictTo("admin", "teacher"),
  unassignClassesFromExam
);

// Get students who sat for an exam
router.get("/:id/students", getStudentsForExam);

export default router;

  ]
  exammodel: [
    import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToMany,
  OneToMany,
  JoinTable,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";
import { Length, IsDate, IsInt, Min } from "class-validator";
import { Class } from "./classModel";
import { Student } from "./studentModel";
import { Result } from "./resultModel";

@Entity()
export class Exam {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column()
  @Length(2, 100)
  name: string;

  @Column()
  @IsDate()
  date: Date;

  @ManyToMany(() => Class, (cls) => cls.exams, { cascade: true })
  @JoinTable()
  classes: Class[];

  @ManyToMany(() => Student, (student) => student.exams, { cascade: true })
  @JoinTable()
  students: Student[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Inside Exam class
  @OneToMany(() => Result, (result) => result.exam)
  results: Result[];
}
  ]
]
[
  guardianroutes: [
import { Router } from "express";
import {
  createGuardian,
  getAllGuardians,
  getGuardianById,
  updateGuardian,
  deleteGuardian,
} from "../controllers/guardianController";
import { validateUUID } from "../middleware/validateUUID";
import { protect, restrictTo } from "../middleware/authMiddleware";

const router = Router();

router.post("/", protect, restrictTo("admin"), createGuardian);
router.get("/", getAllGuardians);
router.get("/:id", validateUUID, getGuardianById);
router.put("/:id", protect, restrictTo("admin"), validateUUID, updateGuardian);
router.delete(
  "/:id",
  protect,
  restrictTo("admin"),
  validateUUID,
  deleteGuardian
);

export default router;

  ]
  guardianmodel: [
    // src/models/guardianModel.ts

import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
  Length,
  Matches,
} from "class-validator";
import { Student } from "./studentModel";

@Entity()
export class Guardian {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column()
  @IsNotEmpty()
  @IsString()
  @Length(2, 100)
  name: string;

  @Column({ unique: true })
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @Column({ unique: true })
  @IsNotEmpty()
  @IsString()
  @Matches(/^\d{7,15}$/, {
    message: "Phone must be digits only and 7 to 15 characters long",
  })
  phone: string;

  @Column({ nullable: true })
  @IsOptional()
  @IsString()
  @Length(6, 100)
  password?: string;

  @OneToMany(() => Student, (student) => student.guardian)
  students: Student[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

  ]

]
[
  resultroutes: [
import { Router } from "express";
import multer from "multer";
import {
  uploadResults,
  getResultsByExam,
  getResultsByStudent,
  analyzeSubjectInExam,
  compareStudentResults,
} from "../controllers/resultController";
import { protect, restrictTo } from "../middleware/authMiddleware";

const router = Router();
const upload = multer(); // Memory storage for Excel upload

router.post(
  "/upload",
  upload.single("file"),
  protect,
  restrictTo("admin", "teacher"),
  uploadResults
);

router.get("/exam/:examId", getResultsByExam);

router.get("/student/:studentId", getResultsByStudent);

router.get("/analyze/:examId/:subject", analyzeSubjectInExam);

router.get("/compare/:studentId", compareStudentResults);

export default router;

  ]

  resultmodel: [
    import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
  Unique,
  CreateDateColumn,
  UpdateDateColumn,
  ValueTransformer,
} from "typeorm";
import { Exam } from "./examModel";
import { Student } from "./studentModel";

// Transformer to round numbers to 2 decimal places
const twoDpTransformer: ValueTransformer = {
  to: (value: number) => {
    if (typeof value === "number") {
      return Math.round(value * 100) / 100;
    }
    return value;
  },
  from: (value: number) => value,
};

@Entity()
@Unique(["exam", "student"])
export class Result {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @ManyToOne(() => Exam, (exam) => exam.results, { onDelete: "CASCADE" })
  @JoinColumn({ name: "examId" })
  exam: Exam;

  @Column()
  examId: string;

  @ManyToOne(() => Student, (student) => student.results, {
    onDelete: "CASCADE",
  })
  @JoinColumn({ name: "studentId" })
  student: Student;

  @Column()
  studentId: string;

  // Use jsonb but round each subject score on save
  @Column("jsonb", {
    transformer: {
      to: (subjectScores: Record<string, number | null>) => {
        const roundedScores: Record<string, number | null> = {};
        for (const subject in subjectScores) {
          const score = subjectScores[subject];
          if (typeof score === "number") {
            roundedScores[subject] = Math.round(score * 100) / 100;
          } else {
            roundedScores[subject] = score;
          }
        }
        return roundedScores;
      },
      from: (value: Record<string, number | null>) => value,
    },
  })
  subjectScores: Record<string, number | null>;

  @Column("numeric", { precision: 10, scale: 2, transformer: twoDpTransformer })
  totalScore: number;

  @Column("numeric", { precision: 10, scale: 2, transformer: twoDpTransformer })
  meanScore: number;

  @Column()
  grade: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

  ]
]
[
  studentroutes: [
// src/routes/studentRoutes.ts
import { Router } from "express";
import {
  createStudent,
  getAllStudents,
  getStudentById,
  updateStudent,
  deleteStudent,
  bulkDeleteStudents,
  getStudentSubjects,
} from "../controllers/studentController";
import { validateUUID } from "../middleware/validateUUID";
import { protect, restrictTo } from "../middleware/authMiddleware";
const router = Router();

router.post("/", protect, restrictTo("admin"), createStudent);
router.get("/", getAllStudents);
router.get("/:id", validateUUID, getStudentById);
router.put("/:id", protect, restrictTo("admin"), validateUUID, updateStudent);
router.delete(
  "/:id",
  protect,
  restrictTo("admin"),
  validateUUID,
  deleteStudent
);
router.post("/bulk-delete", protect, restrictTo("admin"), bulkDeleteStudents); //array ids[string]

router.get("/:id/subjects", validateUUID, getStudentSubjects);

export default router;

  ]
  studentmodel: [
    import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  ManyToOne,
  OneToMany,
  ManyToMany,
  JoinTable,
  JoinColumn,
} from "typeorm";
import { IsNotEmpty, IsString, IsUUID } from "class-validator";
import { Class } from "./classModel";
import { Guardian } from "./guardianModel";
import { Subject } from "./subjectModel";
import { Exam } from "./examModel";
import { Result } from "./resultModel";

@Entity()
export class Student {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ name: "adm_no", unique: true })
  @IsNotEmpty()
  @IsString()
  admNo: string;

  @Column()
  @IsNotEmpty()
  @IsString()
  name: string;

  @ManyToOne(() => Class, (classEntity) => classEntity.students)
  @JoinColumn({ name: "class_id" })
  class: Class;

  @Column({ name: "class_id" })
  @IsNotEmpty()
  @IsUUID()
  classId: string;

  @ManyToOne(() => Guardian, (guardian) => guardian.students, {
    nullable: true,
    onDelete: "SET NULL",
  })
  @JoinColumn({ name: "guardian_id" })
  guardian?: Guardian | null;

  @Column({ name: "guardian_id", nullable: true })
  guardianId: string | null;

  @ManyToMany(() => Subject, (subject) => subject.students, { cascade: true })
  @JoinTable({
    name: "student_subjects", // junction table name
    joinColumn: {
      name: "student_id",
      referencedColumnName: "id",
    },
    inverseJoinColumn: {
      name: "subject_id",
      referencedColumnName: "id",
    },
  })
  subjects: Subject[];

  @ManyToMany(() => Exam, (exam) => exam.students)
  exams: Exam[];

  // Inside Student class
  @OneToMany(() => Result, (result) => result.student)
  results: Result[];
}

  ]
]
[
  subjectroutes: [
import { Router } from "express";
import {
  assignSubjectsToStudent,
  unassignSubjectsFromStudent,
  createSubject,
  getAllSubjects,
  getSubjectById,
  updateSubject,
  deleteSubject,
  bulkAssignSubjectsToStudents,
  bulkUnassignSubjectsFromStudents,
} from "../controllers/subjectController";
import { protect, restrictTo } from "../middleware/authMiddleware";

const router = Router();

router.post("/", protect, restrictTo("admin"), createSubject);
router.get("/", getAllSubjects);
router.get("/:id", getSubjectById);
router.put("/:id", protect, restrictTo("admin"), updateSubject);
router.delete("/:id", protect, restrictTo("admin"), deleteSubject);

// router.post("/assign", assignSubjectsToStudent);
// router.post("/unassign", unassignSubjectsFromStudent);
router.post(
  "/bulk-assign",
  protect,
  restrictTo("admin", "teacher"),
  bulkAssignSubjectsToStudents
);
router.post(
  "/bulk-unassign",
  protect,
  restrictTo("admin", "teacher"),
  bulkUnassignSubjectsFromStudents
);

export default router;

  ]
  subjectmodel: [
    import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToMany,
  Unique,
} from "typeorm";
import { IsNotEmpty, IsString, Matches, IsUUID } from "class-validator";
import { Student } from "./studentModel";

@Entity()
@Unique(["name"])
export class Subject {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column()
  @IsNotEmpty()
  @IsString()
  @Matches(/^[a-z]+$/, {
    message: "Subject name must be lowercase with no spaces",
  })
  name: string;

  @ManyToMany(() => Student, (student) => student.subjects)
  students: Student[];
}

  ]
]
[
  teacherroutes: [
import { Router } from "express";
import {
  createTeacher,
  getAllTeachers,
  getTeacherById,
  updateTeacher,
  deleteTeacher,
} from "../controllers/teacherController";
import { validateUUID } from "../middleware/validateUUID";
import { protect, restrictTo } from "../middleware/authMiddleware";

const router = Router();

router.post("/", protect, restrictTo("admin"), createTeacher);
router.get("/", protect, restrictTo("teacher"), getAllTeachers);
router.get("/:id", validateUUID, getTeacherById);
router.put("/:id", protect, restrictTo("admin"), validateUUID, updateTeacher);
router.delete(
  "/:id",
  protect,
  restrictTo("admin"),
  validateUUID,
  deleteTeacher
);

export default router;

  ]
  teachermodel: [
    // src/models/teacherModel.ts

import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  OneToOne,
  JoinColumn,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";
import {
  IsEmail,
  IsNotEmpty,
  IsString,
  Length,
  Matches,
  IsUUID,
  IsOptional,
} from "class-validator";
import { Class } from "./classModel";

@Entity()
export class Teacher {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column()
  @IsNotEmpty()
  @IsString()
  @Length(2, 100)
  name: string;

  @Column({ unique: true })
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @Column({ unique: true })
  @IsString()
  @IsNotEmpty()
  @Matches(/^\d{7,15}$/, {
    message: "Phone number must be digits only and 7 to 15 characters long",
  })
  phone: string;

  @Column({ nullable: true })
  @IsOptional()
  @IsString()
  @Length(6, 100)
  password?: string;

  @OneToOne(() => Class, (cls) => cls.teacher, { cascade: false })
  @JoinColumn({ name: "class_id" })
  class: Class;

  @Column({ name: "class_id" })
  @IsNotEmpty()
  @IsUUID()
  classId: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
  ]

]


main base endpoints: [app.use("/api/students", studentRoutes);
app.use("/api/classes", classRoutes);
app.use("/api/teachers", teacherRoutes);
app.use("/api/admins", protect, restrictTo("admin"), adminRoutes);
app.use("/api/guardians", guardianRoutes);
app.use("/api/subjects", subjectRoutes);
app.use("/api/exams", examRoutes);
app.use("/api/results", resultRoutes);
]
